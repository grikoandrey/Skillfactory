from random import randint
from colorama import Fore, Style  # Загрузка дополнительных библиотек

"""ДЛЯ ПРОВЕРКИ!!!!!!!!! В методе "generate_board" есть задокументированный вариант быстрой проверки 
работы алгоритма игры, там расстановка на полях идентична друг другу"""

"""
Структурное описание принципа игры "Морской бой" и взаимодействие с кодом:
1. Игровое поле:
    Игра проходит на двух игровых полях: пользовательском и компьютерном.
    Поля представляют собой квадратные сетки, разделенные на клетки.
    Каждая клетка может содержать информацию о наличии корабля или его части, а также о результатах выстрелов.
2. Корабли:
    Игроки имеют флот кораблей различной длины.
    Корабли могут быть расположены вертикально или горизонтально.
3. Очередность хода:
    Ходы осуществляются поочередно между игроками. Игроки выбирают координаты для выстрела.
4. Правила выстрела:
    После каждого выстрела игрок получает информацию о попадании, промахе или уничтожении корабля.
    Выстрелы обозначаются на поле символами: 'X' - попадание, 'M' - мимо.
5. Цель игры:
    Целью каждого игрока является уничтожение всех кораблей противника.
6. Классы и структура кода:
    Dot: Представляет координаты клетки на поле.
    BoardException и его подклассы: Обработка исключений, связанных с игровой доской.
    Ship: Представляет корабль с его координатами и состоянием.
    Board: Представляет игровую доску с методами для размещения кораблей и выстрелов.
    Player, User, Computer: Классы, представляющие игроков и их поведение.
    Game: Основной класс, управляющий ходом игры и взаимодействием между игроками.
7. Взаимодействие классов:
    Dot: Используется для представления координат на игровой доске.
    Ship: Хранит информацию о корабле, его состоянии и координатах.
    Board: Отвечает за управление состоянием игровой доски, размещение кораблей и обработку выстрелов.
    Player, User, Computer: Предоставляют интерфейс для хода игрока и компьютера.
    Game: Координирует и управляет основным циклом игры.
8. Взаимодействие с пользователем:
    User: Ввод координат для выстрела от пользователя через консоль.
    Computer: Автоматический выбор координат для выстрела компьютером.
9. Игровой цикл:
    Game: Содержит методы для начала, проведения и завершения игры.
    generate_board: Генерация расстановки кораблей на доске.
    game_loop: Основной цикл игры с обработкой ходов игроков.
10. Правила и исключения:
- OutOFBoard, DoubleShot, WrongPlace: Классы исключений для обработки ситуаций, связанных с игровой доской и выстрелами.
11. Вывод результатов:
- print_field: Вывод текущего состояния доски в консоль с учетом различных символов для кораблей, попаданий и контура.
"""


class Dot:
    """Отдельный класс для часто используемого элемента "точка" в обмене и логике """
    def __init__(self, x: int, y: int):  # инициализация координат точки
        self.x = x
        self.y = y

    def __eq__(self, other: 'Dot') -> bool:
        """переопределние способа сравнения координат для удобства"""
        return self.x == other.x and self.y == other.y

    def __repr__(self) -> str:
        """переопределение способа вывода координат"""
        return f"Dot({self.x}, {self.y})"


class BoardException(Exception):
    """Общий класс исключений"""
    pass


class OutOfBoard(BoardException):
    """наследуемое исключение для ввода координат за пределами поля"""
    def __init__(self) -> None:
        super().__init__("Выстрел в точку за пределами доски! Уточните число и проверьте язык раскладки")


class DoubleShot(BoardException):
    """наследуемое исключение для повторного хода в занятую точку"""
    def __init__(self) -> None:
        super().__init__("Повторный выстрел в точку!")


class WrongPlace(BoardException):
    """наследуемое исключение для неправильной расстановки кораблей"""
    pass


class Ship:
    """класс "Корабль" определяющий параметры: начальная точка, ориентация, размер"""
    def __init__(self, start_dot: Dot, orientation: str, size: int):
        self.start_dot: Dot = start_dot
        self.orientation: str = orientation
        self.size: int = size
        self.lives: int = size

    @property
    def ship_dots(self) -> list[Dot]:
        """метод хранения и обработки точек, занимаемых кораблем"""
        ship_dots = []  # создание пустого списка точек корабля
        for i in range(self.size):  # цикл по точкам корабля в пределах его длины
            if self.orientation == 'horizontal':  # определение ориентации
                ship_dots.append(Dot(self.start_dot.x + i, self.start_dot.y))  # добавление точки по "у"
            else:
                ship_dots.append(Dot(self.start_dot.x, self.start_dot.y + i))  # иначе точка по "х"
        return ship_dots  # возврат списка точек всего корабля

    def contour_dots(self) -> list[Dot]:
        """метод хранения и обработки точек контура вокруг корабля"""
        contour_dots = []  # создание пустого списка контура
        for dot in self.ship_dots:  # проход по точкам корабля
            near = [
                (-1, -1), (-1, 0), (-1, 1),
                (0, -1), (0, 0), (0, 1),
                (1, -1), (1, 0), (1, 1)
            ]
            for dx, dy in near:  # проход по списку координат вокруг точки
                cur = Dot(dot.x + dx, dot.y + dy)  # определение координат точки контура
                contour_dots.append(cur)  # добавление координат текущей точки в список
        return contour_dots  # возврат списка точек контура

    def is_sunk(self) -> bool:
        """метод для проверки количества "жизней" кораблей"""
        return self.lives == 0


class Board:
    """класс "Доска" определящий отображение, поведение точек на ировом поле, логику хода игрока"""
    def __init__(self, size: int) -> None:
        self.size: int = size  # размер игрового поля
        self.board = self.empty_board()  # инициализация чистого поля
        self.ships: list[Ship] = []  # инициализация списка кораблей
        self.busy: list[Dot] = []  # инициализация списка занятых точек на поле

    def empty_board(self) -> [list[str]]:
        """метод для создания пустой доски в виде двухмерной матрицы"""
        return [["≈ "] * self.size for _ in range(self.size)]

    def place_ship(self, ship: Ship) -> None:
        """Реализация установки корабля на доску"""
        for dot in ship.ship_dots:  # проход по списку из метода точек корабля класса "Корабль"
            if self.out(dot) or dot in self.busy:  # проверка точек корабля на занятость и пределы поля
                raise WrongPlace()
        for dot in ship.ship_dots:
            self.board[dot.y][dot.x] = "■ "  # размещение символа точки корабля на пустом поле
            self.busy.append(dot)  # занесение данной точки в список занятых
        self.ships.append(ship)  # занесение отдельного корабля в список кораблей
        self.contour(ship)  # вызов метода на размещение контура вокруг корабля

    def contour(self, ship: Ship, show_contour: bool = False) -> None:
        """метод добавления точек контура на доску, флаг показа контура"""
        for dot in ship.contour_dots():  # проход по списку из метода точек контура класса "Корабль"
            if not self.out(dot) and dot not in self.busy:  # проверка точек корабля на занятость и пределы поля
                if show_contour:  # применение флага показа контура, откроется только после поражения корабля
                    self.board[dot.y][dot.x] = ". "
                self.busy.append(dot)  # занесение точек в список занятых

    def print_field(self, field1: list[str], field2: list[str], hide_ships: bool = True) -> None:
        """ метод для вывода состояния доски в консоль """
        letters = [chr(i) for i in range(ord('A'), ord('A') + self.size)]  # Генерация латинских букв
        numeric_row = [f"{i + 1}" for i in range(self.size)]  # Генерация числовой строки
        print(f"{Fore.BLUE}Поле Пользователя:" + " "*(self.size*5) + f"{Fore.RED}Поле компьютера:")  # обозначение полей
        print(" "*2 + "  ".join(f"{Fore.BLUE}{num}{Style.RESET_ALL}" for num in numeric_row) + " "*25 +  # Выводим
              "  ".join(f"{Fore.BLUE}{num}{Style.RESET_ALL}" for num in numeric_row))  # изменяемую числовую строку

        for row1, row2, letter in zip(field1, field2, letters):  # Выводим матрицы
            if hide_ships:  # флаг скрытия кораблей на поле компьютера
                row2 = [cell.replace("■ ", '≈ ') for cell in row2]  # замена отображения кораблей на поле по флагу
            print(f"{Fore.RED}{letter}{Style.RESET_ALL} {' '.join(row1)} {' '*20} "
                  f"{Fore.RED}{letter}{Style.RESET_ALL} {' '.join(row2)}")  # вывод поля в консоль построчно

    def out(self, dot: Dot) -> bool:
        """проверка введенных координат на попадание в поле"""
        return not (0 <= dot.x < self.size and 0 <= dot.y < self.size)

    def shoot(self, dot: Dot) -> bool:
        """метод для реализации выстрела по доске"""
        if self.out(dot):  # проверка на границы поля
            raise OutOfBoard()
        elif dot in self.busy:  # проверка на повторный выстрел в точку
            raise DoubleShot()
        else:
            self.busy.append(dot)  # добавление точки выстрела в список занятых
            for ship in self.ships:  # проходим по списку кораблей
                if dot in ship.ship_dots:  # проходим по точкам корабля, вызывая метод из класса "Корабль"
                    ship.lives -= 1  # если попали (ранение) в корабль уменьшаем количество жизней (по размеру)
                    self.board[dot.y][dot.x] = "X "  # заменяем на символ "Х"
                    if ship.lives == 0:  # если у корабля кочились жизни, то он уничтожен
                        self.contour(ship, show_contour=True)  # вызываем метод для открытия контура корабля через флаг
                        print("Корабль уничтожен!")
                    else:
                        print("Корабль ранен!")
                    return True
            self.board[dot.y][dot.x] = "M "  # если не корабль, то промах
            print("Мимо! Переход хода.")
            return False

    def clear_board(self) -> None:
        """очистка поля от занятых точек перед началом игры после расстановки кораблей"""
        self.busy = []


class Player:
    """родительский класс создания игрока со своей доской"""
    def __init__(self) -> None:  # инициализация игрока с доской
        self.board: Board = Board(size=6)

    def make_shot(self) -> Dot:
        """абстрактный метод для создания выстрела"""
        raise NotImplementedError()

    def turn(self) -> None:
        """метод для определения хода игрока"""
        while True:  # бесконечный цикл
            try:  # конструкция для отлова исключений
                shot_dot = self.make_shot()  # делается ход выстрелом в точку
                repeat_turn = self.board.shoot(shot_dot)  # вызывается метод выстрела
                if not repeat_turn:  # если повтора нет, то заканчиваем сменой хода
                    break
            except (OutOfBoard, DoubleShot) as e:  # вызов исключений в случае за границы или повторно
                print(e)
                continue  # продолжаем для следующего хода


class User(Player):
    """дочерний класс от "Игрок"""
    def __init__(self) -> None:
        """инициирует получение доски противника для выстрела"""
        super().__init__()
        self.comp_board: Board = Board(size=6)

    def make_shot(self) -> Dot:
        """метод для ввода координат пользователя"""
        user_input = input("\nВаш ход (введите координаты через пробел, например, 'A 1'): ").upper()
        y, x = user_input.split()  # обработка введенных координат от пользователя
        y = ord(y) - ord('A')  # перевод координат
        x = int(x) - 1  # перевод координат
        return Dot(x, y)  # возврат координат точки выстрела


class Computer(Player):
    """дочерний класс от "Игрок"""
    def __init__(self) -> None:
        """инициирует получение доски противника для выстрела"""
        super().__init__()
        self.user_board: Board = Board(size=6)

    def make_shot(self) -> Dot:
        """метод для ввода координат компьютера"""
        x = randint(0, self.board.size - 1)  # произвольный выбор координаты
        y = randint(0, self.board.size - 1)  # произвольный выбор координаты
        print(f"Ход компьютера: {chr(ord('A') + y)} {x+1} ")  # вывод на экран координат выстрела компьютера
        return Dot(x, y)  # возврат координат точки выстрела


class Game:
    """основной класс, представляющий логику игры"""
    def __init__(self) -> None:
        """инициализация игроков (пользователя и компьютера)"""
        self.user: User = User()  # пользователь
        self.computer: Computer = Computer()  # компьютер

    @staticmethod
    def welcome() -> None:
        """метод для вывода приветствия"""
        print("--------------------------------------")
        print("Добро пожаловать в игру 'Морской бой'!")
        print("--------------------------------------")
        print("Выбрав определенный размер, на игровом поле будет размещено разное количество кораблей:")
        print("Поле 6 (базовое): 1 - трехпалубный, 2 - двухпалубных, 2 - однопалубных")
        print("Поле 7: к базовым добавится 1 - однопалубный")
        print("Поле 8: к базовым добавится 1 - двухпалубный и 1 - однопалубный")
        print("Поле 9: к базовым добавится 1 - трехпалубный, 1 - двухпалубный и 2 - однопалубных")
        print("--------------------------------------")

    def manual_input(self) -> None:
        """метод для ввода размера игрового поля"""
        while True:  # вызов бесконечного цикла
            try:  # конструкция для отлова исключения
                size = int(input("Введите размер игрового поля (от 6 до 9): "))  # ввод размера поля
                if 6 <= size <= 9:  # условие требуемого выполнения
                    self.user._board = Board(size=size)  # создание доски пользователя
                    self.computer._board = Board(size=size)  # создание доски компьютера
                    break  # прерывание по корректному вводу размера
                else:  # условие на ввод числа за пределами диапазона
                    print("Размер поля должен быть от 6 до 9. Попробуйте снова.")
            except ValueError:  # исключение на ввод любых символов, отличных от цифр
                print("Неверный формат ввода. Попробуйте снова.")

    def generate_board(self, player: Player) -> Board:
        """метод для генерации расстановки кораблей"""
        # Временный код для быстрой проверки игрового цикла --------------------------------------
        # ships_to_place = [
        #     Ship(Dot(0, 0), 'horizontal', 3),
        #     Ship(Dot(4, 5), 'horizontal', 2),
        # ]
        # for ship in ships_to_place:
        #     player.board.place_ship(ship)
        # player.board.clear_board()
        # Это код генерации расстановки кораблей, для быстроты проверки он временно отключен,
        # чтобы его включить в работу, необходимо его раздокументировать, а выше расположенный код,
        # наоборот, задокументировать --------------------------------------------------------------------
        ship_sizes = [3, 2, 2, 1, 1]  # базовый список количества и размеров кораблей
        if player.board.size == 7:  # условие увеличения поля
            ship_sizes.append(1)  # добавление в базовый список корабля
        elif player.board.size == 8:  # условие увеличения поля
            ship_sizes.extend([2, 1])  # добавление в базовый список кораблей
        elif player.board.size == 9:  # условие увеличения поля
            ship_sizes.extend([3, 2, 1, 1])  # добавление в базовый список кораблей
        player.board = Board(size=self.user.board.size)  # создание поля с заданными размерами от пользователя
        for size in ship_sizes:  # проходимся по списку кораблей, учитывая количество и размерность
            while True:  # бесконечный цикл
                orientation = randint(0, 1)  # произвольный выбор ориентации
                if orientation == 0:  # горизонтальное расположение
                    ship = Ship(Dot(randint(0, self.user.board.size - 1),  # генерируем добавление точек по условиям
                                    randint(0, self.user.board.size - size)), 'horizontal', size)
                else:  # вертикальное расположение
                    ship = Ship(Dot(randint(0, self.user.board.size - size),  # генерируем добавление точек по условиям
                                    randint(0, self.user.board.size - 1)), 'vertical', size)
                try:  # конструкция для отлова исключений
                    player.board.place_ship(ship)  # выполняем - объект "корабль" размещаем на игровой доске по порядку
                    break  # прерываем после успешной расстановки, корабли не накладываются друг на друга
                except WrongPlace:  # поднимаем пустое исключение (на всякий случай) =)
                    pass
        player.board.clear_board()  # очищаем список занятых точек для дальнейшей игры
        return player.board  # возвращаем игровое поле

    @staticmethod
    def rules() -> None:
        """метод для вывода правил игры"""
        print("\nПравила игры:")
        print("1. Выстрелы осуществляются поочередно.")
        print("2. Ход состоит из выбора координат для выстрела в формате: строка, столбец через пробел.")
        print("3. 'X' - попадание, 'M' - мимо.")
        print("4. Цель игры - уничтожить все корабли противника.")
        print("_______________Да начнется битва!_______________")

    def check_victory(self, board, message: str) -> bool:
        """метод для проверки условия победы"""
        if not any(ship.lives for ship in board.ships):  # проверка условия оставшихся жизней всех кораблей на поле
            self.user.board.print_field(self.user.board.board, self.computer.board.board)  # Выводим поле после победы
            print(message)  # вывод заданного сообщения
            return True  # вывод булевого значения в зависимости от условия
        return False  # вывод булевого значения в зависимости от условия

    def game_loop(self) -> None:
        """Реализация основного игрового цикла"""
        game_over = False  # дополнительная переменная
        user_turn = True  # дополнительная переменная

        while not game_over:  # цикл с условием пока игра продолжается
            self.user.board.print_field(self.user.board.board, self.computer.board.board)  # Вывод текущего состояния
            try:  # конструкция для отлова исключений для правильности осуществления хода
                if user_turn:  # условие хода пользователя, с него начинается
                    user_shot = self.user.make_shot()  # Ввод координат пользователя
                    repeat_turn_user = self.computer.board.shoot(user_shot)  # выстрел по точке поля компьютера
                    if not repeat_turn_user:  # если условие Мимо False, то меняем ход
                        user_turn = False  # Переход хода компьютеру после успешного выстрела пользователя
                else:  # смена хода
                    computer_shot = self.computer.make_shot()  # Ход компьютера
                    repeat_turn_computer = self.user.board.shoot(computer_shot)  # выстрел по точке поля пользователя
                    if not repeat_turn_computer:  # если промах, то возвращаем условие для хода пользователя
                        user_turn = True  # Переход хода пользователю после успешного выстрела компьютера
                if self.check_victory(self.computer.board, f"------Вы победили!------" * 6):
                    game_over = True  # проверка на условие остатка всех жизней на доске компьютера
                if self.check_victory(self.user.board, "Компьютер победил. Попробуйте еще раз!"):
                    game_over = True  # проверка на условие остатка всех жизней на доске пользователя
            except (OutOfBoard, DoubleShot) as e:  # вызов исключений
                print(e)
                continue  # продолжаем пока не наступило условие

    def start(self) -> None:
        """метод для запуска игры"""
        self.welcome()  # вывод приветствия в консоль
        self.manual_input()  # ввод размеров поля от пользователя
        self.generate_board(self.user)  # генерация поля пользователя
        self.generate_board(self.computer)  # генерация поля компьютера
        self.rules()  # вывод провил игры в консоль
        self.game_loop()  # запуск игрового цикла


if __name__ == "__main__":
    game = Game()  # создание объекта класса "игра"
    game.start()  # запуск игры через метод "старт"
